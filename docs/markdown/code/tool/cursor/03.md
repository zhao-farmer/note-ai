

# 三、Cursor精准上下文指定

在 Cursor 工具里，“上下文（Context）” 可理解为 **让 AI 准确理解需求、辅助编码的 “信息参考范围”** ，是 AI 读懂代码、精准响应的关键!

## 3.1 Codebase Indexing 代码库索引

### 3.1.1 概念和作用

打开项目时，每个 Cursor 实例都将初始化该工作区的索引。初始索引设置完成后，Cursor 将自动为添加到工作区的任何新文件编制索引，以使您的代码库上下文保持最新：

- 快速 “读懂” 你的项目结构（哪些是工具文件、哪些是业务逻辑）
- 定位相关代码（如搜索 `getUser` 时，知道优先查 `userService.js`）
- 理解代码关系（如 `Order` 类和 `Product` 类的关联）

**Cursor 中的作用**：AI 分析索引内容后，生成代码时会更贴合项目实际（如使用已有工具函数、遵循命名规范）。

### 3.1.2 代码库索引配置和示例

代码库索引的状态位于 ` cursor settings >  Indexing & Docs `![](/code/tool/cursor/029.png)

测试示例：

``` 
查看当前项目结构，并使用文字图形形式罗列出来！
```

展示效果：

![](/code/tool/cursor/030.png)

### 3.1.3 忽略文件配置

Cursor 读取项目的代码库并为其编制索引以支持其功能。可以通过将 `.cursorignore` 文件添加到根目录来控制 哪些文件被忽略和Cursor限制访问。

- **提升索引速度**：排除大型依赖、生成文件（如 `node_modules`、`dist`）
- **避免干扰**：某些配置文件可能包含敏感信息或与当前任务无关

配置 `.cursorignore`忽略文件：

* 自己创建 `.cursorignore` 文件添加到代码库目录的根目录下，并列出要忽略的目录和文件

* 使用cursor配置快捷创建忽略文件 `cursor setting > indexing >  Configure ignored files`

  ![](/code/tool/cursor/031.png)

忽略文件配置测试：

1. 创建忽略文件

   ![](/code/tool/cursor/032.png)

2. 添加忽略配置

   ``` 
   # Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
   index.html
   style.css
   main.js
   ```

3. 测试示例

   ``` 
   查看当前项目结构，并使用文字图形形式罗列出来！
   ```

4. 效果展示

    ![](/code/tool/cursor/033.png)


## 3.2 Rules 规则


### 3.2.1 规则介绍

Rules是给Cursor AI功能（规则适用于 Chat和 Cmd K）生成结果添加规则和限制，让 AI 生成的代码贴合团队规范，减少人工二次修改成本，主要的作用如下：

- 可约束代码风格（如强制用驼峰命名、要求函数必须写注释 ）
- 能限定技术选型（如禁止使用某老旧库、优先用项目指定工具类 ）
- 提前指定核心参数（如提前设置连接数据库的地址和账号密码等）

**Rule主要的配置方案有两种：**

| **维度**     | **项目规则（Project Rules）**                | **用户规则（User Rules）**           |
| ------------ | -------------------------------------------- | ------------------------------------ |
| **作用范围** | 仅对当前项目生效，团队成员共享相同规则       | 对所有项目生效，个人专属配置         |
| **存储位置** | 项目根目录下的 `.cursor/rules/随意.mdc` 文件 | 用户配置目录（如 `~/.cursor/rules`） |
| **同步方式** | 随项目代码提交到版本库（如 Git），团队共享   | 仅本地生效，不随项目同步             |
| **适用场景** | 统一团队编码规范（如函数注释格式、依赖版本） | 个人习惯（如快捷键、AI 响应风格）    |

<font color='red'>注意： 项目规则和用户规则同时存在并且规则冲突，项目规则优先级更高~~</font>

### 3.2.2 项目规则配置

1. 项目下创建规则文件

    * 创建文件夹自定义文件`项目/.cursor/rules/随意命名.mdc`
    * 快捷命令方式创建 `Ctrl + Shift + P` > “New Cursor Rule”


    ![](/code/tool/cursor/034.png)


2. 编写项目规则文件

   ``` 
   ---
   description: "团队前端项目规范"
   priority: 1000
   ---
   
   # 代码风格
   1. 函数必须包含 JSDoc 注释
   2. 禁止使用 `var`，统一用 `const`/`let`
   3. 函数命名必须添加 zwf_前缀， 例如：zwf_login
   
   # 依赖管理
   - 优先使用项目内已有的工具函数（如 `utils/request`）
   - 禁止引入低版本的 lodash（<4.0.0）
   ```

3. 项目规则文件生效测试

   1. 准备一个main.js文件

   2. 进入ctrl + k 

   3. 内联生成函数，查看是否规则生效

      ``` 
      生成两个方法一个登录一个注册！
      ```

4. 项目规则生效效果展示

   ![](/code/tool/cursor/035.png)

### 3.2.3 用户规则配置

1. 用户规则在**cursor settings >  rules**中定义。

2. 添加规则内容即可

3. 用户规则不支持 MDC，它们只是纯文本。

    ![](/code/tool/cursor/036.png)

### 3.2.4 mdc语法了解

Cursor 的 MDC（Markdown with Cursor）语法是专门为编写项目规则设计的轻量级格式，它结合了 Markdown 的可读性和元数据配置能力。接下来，我们来说明下mdc文件语法。

#### 3.2.4.1 MDC 文件组成部分：

1. 前置元数据（Frontmatter）
   - 用 `---` 包裹的 YAML 格式配置
   - 定义规则的基本属性（如作用范围、优先级）
2. 规则内容（Markdown 正文）
   - 用 Markdown 语法写具体规则

#### 3.2.4.2 前置元数据

``` 
---
# 官方约定字段（推荐用，AI 更易理解）
description: "前端项目规则"
globs: "src/**/*.tsx"
priority: 1000

# 自定义字段（自己或团队约定含义）
author: "技术团队"
review_date: "2025-06-04"
special_rule: "仅周一至周五生效"
---
```

常用元数据字段

| 字段          | 作用                                       | 示例                     |
| ------------- | ------------------------------------------ | ------------------------ |
| `description` | 描述规则用途，指导 AI 如何应用规则         | `"前端组件编码规范"`     |
| `globs`       | 指定规则生效的文件范围（支持 glob 语法）   | `"src/**/*.{js,ts,jsx}"` |
| `priority`    | 规则优先级（数值越大越优先），解决规则冲突 | `1000`                   |
| `version`     | 规则版本号（可选）                         | `"1.0.0"`                |

#### 3.2.4.3 规则内容（Markdown 正文）

用 Markdown 的标题、列表、代码块等语法写具体规则，常见结构：

代码风格规则（最常用）

``` 
# 一、代码风格
1. 函数必须包含 JSDoc 注释  
   - 至少包含 `@param` 和 `@return` 描述  
2. 变量命名必须使用驼峰命名法（camelCase）  
3. 每行代码长度不超过 120 个字符  

# 二、技术选型
- 禁止直接使用原生 fetch，必须通过项目封装的 request 工具  
- 优先使用 React Hooks 而非 Class 组件  
```

安全约束规则

```mdc
# 安全规范
1. 禁止使用 eval() 函数  
2. SQL 查询必须使用参数化查询，防止注入攻击  
3. 敏感信息（如 API 密钥）必须从环境变量读取  
```

特殊语法：引用项目文件

用 `@file` 引用项目内的配置文件，让 AI 参考：

```mdc
# 工具链配置
1. ESLint 规则必须符合 @file .eslintrc.js  
2. 测试用例必须遵循 Jest 框架规范  
```

#### 3.2.4.4 **完整示例（TypeScript 项目规则）**

``` 
---
description: "TypeScript 项目编码规范"
globs: "src/**/*.ts"
priority: 1000
---

# 一、基础规范
1. 所有文件必须使用 UTF-8 编码  
2. 统一使用 2 空格缩进  

# 二、类型约束
1. 禁止使用隐式 any 类型  
   - 示例：`const num: number = 123`（显式）  
   - 禁止：`const num = 123`（隐式）  
2. 接口命名必须以 `I` 开头（如 `interface IUser`）  

# 三、项目约束
- 所有 HTTP 请求必须通过 @file src/utils/request.ts 封装的工具  
- 状态管理必须使用 Redux Toolkit，禁止直接修改 state  
```

## 3.3 @ 符号

在 Cursor 中使用 @ 符号在聊天中引用代码、文件、文档和其他上下文的指南，直接更具体的指定上下文环境！

![](/code/tool/cursor/037.png)

以下是所有可用 @ 符号的列表：

- @Files- 引用项目中的特定文件
- @Folders - 引用整个文件夹以获得更广泛的上下文
- @Code - 引用代码库中的特定代码片段或符号
- @Docs- 访问文档和指南
- @Git- 访问 git 历史记录和更改
- @Past Chats- 使用汇总的 Composer 会话
- @Cursor Rules-使用光标规则
- @Web- 参考外部 Web 资源和文档
- @Lint Errors- 引用 lint 错误（仅限Chat）

### 3.3.1 @Files使用和测试

1. 准备测试文件 main.js

   ```javascript
   /**
    * 用户登录方法
    * @param {Object} params - 登录参数
    * @param {string} params.username - 用户名
    * @param {string} params.password - 密码
    * @returns {Promise} 登录结果
    */
   const zwf_login = async (params) => {
     try {
       const response = await request.post('/api/login', params);
       return response.data;
     } catch (error) {
       console.error('登录失败:', error);
       throw error;
     }
   };
   
   /**
    * 用户注册方法
    * @param {Object} params - 注册参数
    * @param {string} params.username - 用户名
    * @param {string} params.password - 密码
    * @param {string} params.email - 邮箱
    * @returns {Promise} 注册结果
    */
   const zwf_register = async (params) => {
     try {
       const response = await request.post('/api/register', params);
       return response.data;
     } catch (error) {
       console.error('注册失败:', error);
       throw error;
     }
   };
   
   ```

2. 测试@File对话

   ``` 
   帮我总结下 @main.js 中包含哪些方法？
   ```

3. 查看对话结果

   ![](/code/tool/cursor/038.png)

### 3.3.2 @Code使用和测试

1. 准备测试文件 main.js

   ``` javascript
   /**
    * 用户登录方法
    * @param {Object} params - 登录参数
    * @param {string} params.username - 用户名
    * @param {string} params.password - 密码
    * @returns {Promise} 登录结果
    */
   const zwf_login = async (params) => {
     try {
       const response = await request.post('/api/login', params);
       return response.data;
     } catch (error) {
       console.error('登录失败:', error);
       throw error;
     }
   };
   
   /**
    * 用户注册方法
    * @param {Object} params - 注册参数
    * @param {string} params.username - 用户名
    * @param {string} params.password - 密码
    * @param {string} params.email - 邮箱
    * @returns {Promise} 注册结果
    */
   const zwf_register = async (params) => {
     try {
       const response = await request.post('/api/register', params);
       return response.data;
     } catch (error) {
       console.error('注册失败:', error);
       throw error;
     }
   };
   ```

2. 测试@Code 对话

   ```
   帮我逐行解释下 @zwf_register 代码的含义！并且最终在源文件中添加注释！
   ```

3. 查看对话结果

   ![](/code/tool/cursor/039.png)

### 3.3.3 @Docs使用和测试

1. @Docs作用说明

   `@Docs` 将 Cursor 连接到来自常用工具和框架的官方文档。当需要以下内容的最新权威信息时，请使用它：

   - API 参考：函数签名、参数、返回类型
   - 入门指南 ：设置、配置、基本用法
   - 最佳做法 ：源中的推荐模式
   - 特定于框架的调试 ：官方故障排除指南

2. @Docs对应文档配置

   可以通过` cursor settings > features > Docs`(cursor近期更新频繁，配置页面会有调整)来进行文档索引配置。粘贴所需文档的 URL 后，将显示以下模式：


   ![](/code/tool/cursor/040.png)

   地址： `https://baomidou.com/introduce/`        （mybatis-plus的官网测试）

   - name：一般用于标识文档的名称、简称或唯一识别名，方便在系统里区分不同文档配置。比如这里填`MyBatis - plus`，就是用框架名称作为文档标识，后续可通过这个`name`快速找到、关联对应的文档配置。

   - prefix：常指文档 URL 的前缀部分，可用于拼接完整文档路径，或作为统一的基础地址标识。像填的`https://baomidou.com` ，可能是该框架文档介绍板块的基础前缀，后续若要拼接具体文档子页面路径（如某个功能详细说明路径 ），可以基于这个`prefix`去扩展，让文档地址管理更规整 。

   - entrypoint：一般是文档的入口地址，即用户访问该文档时最先进入的页面。这里和`prefix`填了一样的地址，说明`https://baomidou.com/introduce/` 就是`MyBatis - plus`文档的起始访问页面，用户通过这个`entrypoint`能直接进入到对应文档内容开始浏览 。

3. 测试@Docs对话

   ``` 
   基于 @MyBatis-plus 查询下乐观锁插件如何使用
   ```

4. 查看对话结果

   ![](/code/tool/cursor/041.png)

### 3.3.4 @Web使用和测试

1. @Web作用说明

   `@Web` 在实时 Internet 上搜索当前信息、博客文章和社区讨论。当您需要时使用它：

   - 最近的教程 ：社区生成的内容和示例
   - 比较 ：比较不同方法的文章
   - 最近更新 ：Very Recent updates or announcement（最近的更新或公告）
   - 多种视角 ：不同的问题处理方法

2. 测试@Web对话

   ``` 
   @Web React 19 的最新性能优化
   ```

3. 查看对话结果

   ![](/code/tool/cursor/042.png)

4. 对比@Docs和MCP配置

   ![](/code/tool/cursor/043.png)

### 3.3.5 @Linter Errors使用和测试

1. @Linter Errors作用和说明

   `@Linter Errors` 符号会自动捕获并提供有关当前活动文件中的任何 linting 错误和警告的上下文。

2. 准备错误代码（BubbleSort.java）

   ``` java
   public class BubbleSort {
       /**
        * 冒泡排序方法
        * @param arr 待排序的数组
        */
       public static void bubbleSort(int[] arr) {
           int n = arr.length;
           // 外层循环控制排序轮数
           for (int i = 0; i < n - 1; i++) {
               // 内层循环进行相邻元素比较和交换
               for (int j = 0; j < n - 1 - i; j++) {
                   // 如果当前元素大于下一个元素，则交换它们
                   if (arr[j] > arr[j + 1]) {
                       int temp = arr[j];
                       arr[j] = arr[j + 1];
                       arr[j + 1] = temp;
                   }
               }
           }
       }
   
       /**
        * 打印数组的辅助方法
        * @param arr 要打印的数组
        */
       public static void printArray(int[] arr) {
           for (int i = 0; i < arr.length; i++) {
               //此处故意出现错误，会出现数组越界
               System.out.print(arr[i+2] + " ");
           }
           System.out.println();
       }
   
       public static void main(String[] args) {
           // 测试数组
           int[] arr = {64, 34, 25, 12, 22, 11, 90};
           
           System.out.println("排序前的数组：");
           printArray(arr);
           
           // 执行冒泡排序
           bubbleSort(arr);
           
           System.out.println("排序后的数组：");
           printArray(arr);
       }
   } 
   ```

3. 测试@Lint Errors 对话

   ``` 
   @Linter Errors 程序运行报错了，你基于报错信息分析下，并且直接解决下错误！
   ```

4. 测试结果

   ![](/code/tool/cursor/044.png)