
# 二、Cursor三大核心AI功能

## 2.1 Tab键：智能小助手

Cursor 的 Tab 键具有强大的代码自动补全功能，基于 AI 模型，能根据代码上下文自动预测并生成代码补全建议和代码修复重构，还可用于导航代码等！

>  `Tab` 键接受建议，也可以通过按 `Esc` 键拒绝建议。要逐字部分接受建议，请按 `Ctrl/⌘ + →`。

### 2.1.1 单行/多行代码补全

- 已有代码片段：

  ```java
  //需求：写一个工具类计算数组平均值
  public class ArrayUtils {
     // 按tab会完成补全
  }
  ```

- 按tab键 → Cursor 自动生成代码：

  ```java
  //需求：写一个工具类计算数组平均值
  public class ArrayUtils {
      public static void main(String[] args) {
          int[] nums = {1,2,3,4,5,6,7,8,9,10};
          System.out.println(average(nums));
      }
      public static double average(int[] nums) {
          int sum = 0;
          for (int num : nums) {
              sum += num;
          }
          return (double) sum / nums.length;
      }
  }
  ```

### 2.1.2  智能代码重写

- 已有代码片段：

  ```java
  import java.util.List;
  import java.util.Arrays;
  import java.util.ArrayList;
  
  public class ArrayUtils {
  
      public void arrayFor() {    
          List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
          List<Integer> evenNumbers = new ArrayList<>();
          for (int num : numbers) {
              if (num % 2 == 0) {
                  evenNumbers.add(num);
              }
          }
      }
  }
  ```

- 按Tab键 → 自动补全：

  ```java
  //在循环上方添加注释：// 使用 Stream 重构
  //光标放在循环代码块的任意位置，按 Tab 键
  public void arrayFor() {    
      List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
      List<Integer> evenNumbers = numbers.stream().filter(num -> num % 2 == 0).collect(Collectors.toList());
  }
  
  ```

### 2.1.3  多行协同优化

Cursor 的 **多行协同优化** 核心能力：多行代码，一次性完成 **语法升级、结构重组、安全修复**。

* 多行数据联想

  ``` java
  int count; // 普通变量
  String name; // 姓名
  boolean isValid; // 是否有效
  double price; // 价格
  //tab 会继续联想变量类型
  ```

* 多行批量修改

  ```java
  public static int add(int a, int b) {
      //代码添加注释
      //
      System.out.println("第一次输出");
      //
      System.out.println("第二次输出");
      //
      System.out.println("第三次输出");
      //
      System.out.println("第四次输出");
      return 0;
  }
  ```

### 2.1.4 光标位置预测

* 准备测试代码

  ```java
  public class ArrayUtils {
      //给下面方法添加注释
      /**
       *
       */
      public static int add(int a, int b) {
          return 0;
      }
  
      /**
       *
       */
      public static int subtract(int a, int b) {
          return 0;
      }
  
      /**
       *
       */
      public static int multiply(int a, int b) {
          return 0;
      }
  
      /**
       *
       */
      public static int divide(int a, int b) {
          return 0;
      }
  
  }
  ```

* 测试案例说明

  ![](/code/tool/cursor/007.png)

### 2.1.5 接受，接受部分和拒绝

* 准备测试类

  ``` java
  public class Student {
       
      private String name;
      private int  age;
      //tab 
      //tab 接收完整补全
      //ctrl + -> 部分和逐步接收补全 [需要开启部分补全配置]
      //esc 或者 继续输入 拒绝补全
  
  }
  ```

* 测试和演示效果

### 2.1.6  Tab相关配置说明

配置修改位置： `cursor settings > features > tab `

- **A powerful Copilot replacement that can suggest changes across multiple lines...**
  
  - 作用：启用 / 禁用 Cursor Tab 功能。
  - 通俗理解：相当于 “总开关”，勾选后才能用 Tab 键触发 AI 代码建议（如多行补全、智能续写）；取消勾选则 Tab 仅作普通缩进。

- **Accept the next word of a suggestion via Ctrl+RightArrow**
  
  - **作用**：开启后，可用 `Ctrl+→`（Windows/Linux）或 `⌘+→`（Mac）**逐个单词接受 AI 建议**。
  - **通俗理解**：AI 给的建议很长时，不想全要？开这个功能，按快捷键 “挑着用”。
- **场景**：比如 AI 建议 `const fullName = firstName + " " + lastName;`，但你只想用 `firstName + " " + lastName` 部分，就可通过该快捷键拆分接受。
  
- **Enable Cursor Tab suggestions in comments**
  
  - **作用**：让 AI 在**注释内容里也提供 Tab 建议**。
  - **通俗理解**：写注释时，AI 帮你补全思路！比如输入 `// 实现冒泡排序的步骤：`，按 Tab 自动续写步骤说明。
- **Show whitespace only Cursor Tab suggestions**
  
  - **作用**：控制是否显示**仅包含空白（空格、换行）的 AI 建议**。
  
  - **通俗理解**：这个配置项决定了 **当按 Tab 时，是否让那些 “只调整空格、换行、缩进（没有实际代码逻辑变化）” 的建议显示出来**。。

  - **案例**：
  
    ```
    public class Demo {
    public void test() {
    System.out.println("Hello");
      if (true) {
    System.out.println("World");
      }
    }
    }
    ```
  
    - 勾选：把光标放在混乱的代码里（比如 `public void test() {` 这行后面） tab 会有修改建议
    - 不勾选：把光标放在混乱的代码里（比如 `public void test() {` 这行后面） tab不会有修改建议
  
- **Tab to import necessary modules with Cursor Tab. Only supports TypeScript**
  - **作用**：在 TypeScript 中，写代码时缺模块，按 Tab 自动帮你**导入依赖**。
  
- **Enable auto import for Python. This is a beta feature.**
  - **作用**：（测试版）为 Python 开启类似功能，按 Tab 自动导入缺失模块。

## 2.2 Chat: 对话模式

Chat（以前称为“Composer”）是 Cursor 的 AI 助手，位于的侧边栏中，可让您通过自然语言与代码库进行交互。您可以提出问题、请求代码编辑、获取终端命令建议等 - 所有这些都无需切换上下文。

<video  src="/code/tool/cursor/overview.mp4"></video>

**Cursor chat 主要功能点：**

- Chat 能够了解代码库并代表我们对其进行更改。这是实现新功能的强大方法，也是功能请求的完美工具。
- Chat通过深入了解我们的代码库以及每个组件如何组合在一起，Chat 可以帮助您重构代码库。
- Chat可以根据我们的需求，从零开始进行项目搭建，包括创建项目结构，安装依赖项，甚至编写初始代码，让我们尽快开始业务编码。
- Chat也可以根据我项目的错误信息，进行错误定位和错误代码直接调整解决。

### 2.2.1 快速开始

 使用 `⌘+L` （Mac） 或 `Ctrl+L` （Windows/Linux） 访问侧边栏中的聊天。用自然语言输入我们的请求，AI 将做出相应的响应。

> 注意： 与Chat 对话时，建议采用清晰、具体的语言格式，最好包含任务类型、上下文描述和具体要求。

以下是几个参考模板：

* **代码生成类**

  ``` 
  [任务类型]：请生成一个 {功能描述} 的 {编程语言/框架} 实现
  
  [具体要求]：
  1. 使用 {特定技术/库}
  2. 包含 {特定功能点}
  2. 符合 {编码规范/设计模式}
  ```

  示例：

  ``` 
  请生成一个学习计划页面的HTML+CSS+JavaScript实现
  
  [具体要求]：
  1. 使用Tailwind CSS v3和Font Awesome
  2. 包含任务添加、编辑、删除功能
  2. 包含日历视图展示学习计划
  4. 包含学习进度可视化图表
  5. 符合现代UI设计原则和响应式设计
  6. 具有平滑的动画和交互效果
  ```
  
* **代码修改类**

  ``` 
  [任务类型]：请帮我修改 {上下文：具体文件/代码片段}，实现 {预期功能}
  
  [当前问题]：{现有的错误/不足描述}
  
  [具体要求]：
  1. 保持 {现有功能/结构} 不变
  2. 使用 {特定方法/技术} 改进
  2. 修复 {具体错误/警告}
  ```

  示例：

  ``` 
  请帮我修改当前的 React 组件，优化列表渲染性能。
  当前问题：滚动时列表卡顿，存在明显性能问题。
  要求：
  1. 保持现有 UI 不变
  2. 使用 React.memo 和虚拟列表技术优化
  2. 添加性能监控日志
  ```

* **代码解释类**

  ``` 
  [任务类型]：请解释 {代码片段/功能模块} 的 {具体方面}
  
  [上下文信息]：{相关业务背景/技术栈}
  
  [具体问题]：
  1. {不理解的语法/逻辑}
  2. {特定设计选择的原因}
  2. {潜在的问题/优化点}
  ```

  示例：

  ``` 
  请解释这段 TypeScript 代码的泛型约束和类型推导逻辑。
  上下文：这是一个用于数据验证的工具函数。
  具体问题：
  1. <T extends object> 这里为什么要加 extends object？
  2. 类型推导是如何工作的？
  2. 是否存在类型安全隐患？
  ```

* **流程自动化类**

  ``` 
  [任务类型]：请创建一个自动化流程，实现 {目标描述}
  
  [操作步骤]：
  1. 从 {数据源} 获取 {数据类型}
  2. 执行 {数据处理/转换操作}
  2. 将结果保存到 {目标位置}
  4. 触发 {后续操作/通知}
  
  [具体要求]：
  1. 使用 {特定工具/API}
  2. 添加 {错误处理/重试机制}
  2. 生成 {日志/报告}
  ```

  示例：

  ``` 
  请创建一个自动化流程，每天凌晨从 GitHub API 获取仓库星标数，保存到 Google Sheets 并生成趋势图。
  要求：
  1. 使用 GitHub REST API v3
  2. 添加异常处理和邮件通知
  2. 生成周/月增长趋势图表
  ```

* **命令行辅助类**

  ``` 
  [任务类型]：请提供 {操作场景} 的 {操作系统} 命令
  
  [具体需求]：
  1. {执行的具体操作}
  2. 包含 {特定参数/选项}
  2. 处理 {特殊情况/错误}
  ```

  示例：

  ``` 
  请提供在 macOS 上批量压缩图片的命令行方案。
  需求：
  1. 将当前目录下所有 PNG/JPG 图片压缩 50%
  2. 保留原始文件并添加 "-compressed" 后缀
  2. 显示每个文件的压缩前后大小对比
  ```

**提示词技巧总结：**

1. **提供上下文**：提及项目语言、框架、业务背景等信息
2. **分点描述**：将复杂需求拆解为具体步骤或要求
3. **使用技术术语**：准确的术语能帮助 AI 更精准理解需求
4. **明确边界**：说明必须保留的现有功能或禁止的实现方式
5. **示例引导**：附上期望输出示例或参考代码风格

### 2.2.2 Chat三种模式

Chat 提供针对特定任务优化的不同模式：

1. Agent代理模式（默认）: 允许Cursor学习和理解我们的项目代码，并且代表们可以直接进行项目代码更改！[识别项目结构]
2. Ask对话模式：获取项目代码相关的解释和答案，但是不会直接修改项目代码！[识别项目结构]
3. Manual手动模式：需要我们执行项目上下文（修改范围，后续会详细讲解）重点编辑！[不识别项目结构]

#### 2.2.2.1 Agent模式体验

Agent 是 Cursor 中的默认且最自主的模式，旨在以最少的指导处理复杂的编码任务。它启用了所有[工具 ]，可以自主探索您的代码库、阅读文档、浏览 Web、编辑文件和运行终端命令以高效完成任务。

![](/code/tool/cursor/008.png)

Agent的能力总结：

* 独立探索您的代码库，识别相关文件，并进行必要的更改
* 使用所有可用工具搜索、编辑、创建文件和运行终端命令
* 全面了解项目结构和依赖关系
* 将复杂任务分解为可管理的步骤并按顺序执行

生成和修改示例：

1. 新打开一个文件夹

2. ctrl + L 进行对话模式（默认 agent）

3. 用例对话

   ``` 
   使用html,css,javascript来实现一个贪吃蛇页面！
   要求：
     1. 要求有积分统计
     2. 页面要有多种背景可以切换
     2. 代码添加中文注释
     4. 不能使用var 只能使用let和const声明变量
   ```

4. 生成代码

5. 运行代码对话

   ``` 
   把index.html页面在浏览器打开
   ```

6. 后续调整代码对话

   ``` 
   在页面中添加倒计时功能，每次60秒！
   ```

Agent的配置选项：

![](/code/tool/cursor/009.png)

![](/code/tool/cursor/010.png)

* Model（选择模型 ）：为代理模式预先选择大模型
* Edit Keybindings（编辑快捷键）： 为agent模式设置快速开启快捷键（默认 ctrl + i）
* Auto-run ( 自动运行 ) ：当你让 Agent 修改代码后，自动执行相关命令（如编译、测试、运行），验证修改的正确性。
* Auto-fix errors ( 自动修复 ) ：当自动运行过程中出现错误（如编译失败、测试报错），Agent 会尝试分析错误信息并自动修复。

错误调试和修改示例：

1. 准备错误信息类

   ```java
   public class ArrayDemo {
       public static void main(String[] args) {
           // 创建一个整数数组
           int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
           
           // 使用for循环输出数组内容
           System.out.println("数组内容如下：");
           for (int i = 0; i < numbers.length; i++) {
               //此处 i + 2就会出现下角标越界错误
               System.out.println("第 " + (i + 1) + " 个元素是: " + numbers[i+2]);
           }
           
           // 使用增强型for循环输出数组内容
           System.out.println("\n使用增强型for循环输出：");
           for (int number : numbers) {
               System.out.print(number + " ");
           }
       }
   } 
   ```

2. 运行报错

   ![](/code/tool/cursor/011.png)

3. 对话解决错误信息

   ![](/code/tool/cursor/012.png)

#### 2.2.2.2 Ask模式体验

Ask 是 Chat 的 “只读” 模式，用于提出问题、探索和了解代码库。它是 Cursor 中的一种内置对话模式！

> 对比：Ask 是其他默认模式（Agent 和 Manual）所独有的，因为它默认不应用任何建议的更改 - 这使它成为一种 “只读” 模式，具有读取文件和其他上下文的完整能力，但不能自行进行任何更改。这对于了解我们可能不想更改的代码库或在实施之前使用 AI 规划解决方案非常有用！

示例用例：

``` 
这个贪吃蛇页面如何添加多种模式！
```

![](/code/tool/cursor/013.png)

Ask的配置选项：

![](/code/tool/cursor/014.png)

- Model （模型） : 预先选择应作为 Ask （Ask ） 的默认模型
- Keybinding : 设置键绑定以切换到 Ask 模式
- 搜索代码库 :  允许 Cursor 搜索它自己的上下文，而不是当你希望 AI 看到文件时，你必须手动 @ 文件作为上下文

#### 2.2.2.3 Manual模式体验（已弃用）

与 Ask 模式不同，它不探索代码库或运行终端命令;它完全取决于您的具体说明和您提供的上下文（例如，通过 `@`文件名），AI 生成修改建议后，还要用户**手动点击 “应用”** 才会改动代码，且通常是**单文件 / 局部代码调整**。


![](/code/tool/cursor/015.png)

示例用例：

``` 
在 @script.js @index.html 中，给所有代码添加注释和解释！
```

![](/code/tool/cursor/016.png)

Manual的配置选项：

![](/code/tool/cursor/017.png)

#### 2.2.2.4 Background智能后台模式

代码质量监控：当你在编写代码时，Background 模式会在后台自动检查代码质量，例如检查代码风格是否符合规范、是否存在潜在的错误等，并提供优化建议。

自动优化代码：如果你希望在编写代码的过程中自动优化代码，Background 模式可以在后台运行，自动发现并修复一些常见的问题，例如性能瓶颈、冗余代码等。

长期项目维护：对于长期维护的项目，Background 模式可以帮助你保持代码的健康状态，自动发现潜在问题并提供修复建议。

不干扰开发流程：如果你希望在编写代码时不受干扰，但又希望在需要时能够获得优化建议，Background 模式是一个很好的选择。它在后台运行，不会打断你的开发流程。


适合自身写代码时进行使用

### 2.2.3 Chat模式的其他细节

#### 2.2.3.1 代码编辑选项

当 Chat 建议更改代码时：

```
修改页面背景，可以添加多种颜色可以选！！
```

1. **Review**：在差异视图中查看建议的更改

   ![](/code/tool/cursor/018.png)

2. **Apply**:  在“ask / Manual ”模式下，使用“应用”按钮显式应用更改

    ![](/code/tool/cursor/019.png)

3. **Accept/Reject(接受/拒绝)** ：进行更改后，决定是保留还是放弃更改(agent模式下)

    ![](/code/tool/cursor/020.png)

#### 2.2.3.2 Checkpoints 数据还原

有时，可能希望恢复到代码库的**先前状态**。Cursor 通过在发出的每个请求以及每次 AI 更改的代码库时自动创建代码库的检查点（Checkpoints）来帮助您解决这个问题。

要恢复到以前的状态，您可以：单击上一个请求的输入框中显示的 `Restore Checkpoint` 按钮，如下所示

![](/code/tool/cursor/021.png)

注意：是回复到本次对话之前的状态！！不是本次对话产生的状态！！

#### 2.2.3.3 历史和新建会话

聊天历史记录已移至命令面板。可以通过 Chat 中的 “Show history” 按钮以及运行命令面板中的 “Show Chat History” 命令来访问它。

![](/code/tool/cursor/022.png)

开启新任务、避免对话混乱、保留特定记录或解决误操作时，需在 Cursor 的 Chat 新建聊天框。

![](/code/tool/cursor/023.png)

### 2.2.4 Chat相关的配置说明

* **Default new chat mode**：设置新聊天默认模式，选 “Agent” 则新聊天默认用智能代理交互 ，决定初始聊天交互载体。
* **Chat text size**：调整 AI 聊天消息文字大小，“Default” 是默认尺寸，可按需改显示效果，让阅读更舒适。
* **Auto - refresh chats**：勾选后，聊天面板闲置再打开时自动新建聊天，保持交互新鲜度，避免旧聊天堆积干扰。
* **Auto - scroll to bottom**：新消息生成时自动滚动到聊天面板底部，不用手动翻，方便实时看最新内容。
* **Auto - apply to files outside context in Manual mode**：手动模式下，允许聊天对当前上下文外文件自动应用更改，拓展操作范围，处理跨文件任务更便捷。
* **Include project structure（BETA）**：勾选后，给模型提供简化目录树，辅助理解代码库布局，让 AI 更贴合项目结构做响应，尚处测试阶段。
* **Full folder contents**：启用后，展示完整文件夹内容而非结构大纲，需详细文件内容时开启，便于深度查看。
* **Enable auto - run mode**：允许 Agent 不经确认自动运行工具（如执行命令、写文件），效率高但有风险，需信任场景用，要留意误操作。
  - **Command allowlist**：仅指定命令能自动执行，精准管控，保障安全又保留特定自动操作。
  - **Command denylist**：列入的命令永不自动执行，规避危险命令，加固安全防线。
* **Delete file protection**：启用后阻止 Agent 自动删文件，防误删关键文件，保护数据安全。
* **MCP tools protection**：开启则 Agent 不能自动运行 MCP 工具，避免工具误操作影响系统。
* **Dot files protection**：已勾选，阻止 Agent 自动改点文件（如.gitignore ），保护版本控制等配置文件。
* **Outside workspace protection**：勾选后，Agent 无法自动创建 / 修改工作区外文件，防止影响外部系统，保障工作区独立性。
* **Dialog ‘Don’t ask again’ preferences**：管理曾选 “不再询问” 的对话框，方便回顾或重置交互确认逻辑。
* **Collapse input box pills in pane or editor**：勾选则折叠聊天面板 / 编辑器输入框里的标识，节省空间，让界面更简洁。
* **Iterate on lints**：启用后，Agent 模式聊天自动迭代修复代码检查（linter ）错误，助力自动代码优化。
* **Hierarchical Cursor Ignore**：启用后，cursorignore 文件规则作用于所有子目录，改配置需重启 Cursor，统一忽略规则时用。
* **Auto - accept diffs**：启用后，合成器里的差异（diffs ）在不在工作树中就会被接受，自动处理版本差异，简化流程。
* **Custom modes（BETA）**：允许创建自定义模式，可按需定制交互逻辑，尚在测试，探索个性化玩法。
* **Play sound on finish（BETA）**：聊天响应完成时播放声音提醒，不用一直盯着，及时知晓结果，测试功能。
* **Auto Group Changes（BETA）**：自动分组聊天会话中与大语言模型（LLM ）交互产生的更改，方便集中 review，测试阶段功能。
* **Web Search Tool（BETA）**：已勾选，允许 Agent/ask 模式聊天联网搜索信息，补充知识，让回答更全面，测试功能 



## 2.3 Ctrl+K: 内联智能修改

> 内联编辑 （Cmd/Ctrl+K） 直接在编辑器窗口中生成新代码或编辑现有代码。
>
> 适合已知并精准修改文件内容！

![](/code/tool/cursor/024.png)

### 2.3.1 触发修改提示框

在 Cursor 中，我们将按 `Ctrl/Cmd K` 时出现的栏称为“Prompt Bar”。它的工作原理类似于用于聊天的 AI 输入框，可以在其中正常键入，或使用 @引用其他上下文（后续讲解）。

Cmd K的模式说明：

* **内联生成**：如果在按 `Ctrl/Cmd K` 时未选择任何代码，Cursor 将根据您在提示栏中键入的提示生成新代码。
* **内联编辑**：对于就地编辑，只需选择要编辑的代码，然后在提示栏中键入即可。

### 2.3.2 Cmd + K 体验

* **内联生成**

  1. 打开 `main.js`，光标放文件末尾（无选中代码）

  2. 按 `Cmd/Ctrl + K`，输入提示：

     ``` 
     生成一个带点击动画的按钮组件，用 JavaScript 实现，点击后控制台打印次数
     ```

  2. 实现效果

     ![](/code/tool/cursor/025.png)

* **内联编辑**

  1. 继续打开刚刚main.js 

  2. 选中init方法，按 `Cmd/Ctrl + K`，输入提示：

     ``` 
     方法添加注释和每行代码添加注释说明！！
     ```

     ![](/code/tool/cursor/026.png)

  2. 实现效果

     ![](/code/tool/cursor/027.png)

### 2.3.3 Terminal Cmd + K 体验

在 Cursor 终端中使用 Cmd K 通过提示栏界面生成和运行命令, 在内置的 Cursor 终端中，您可以按 `Ctrl/⌘ K` 打开终端底部的提示栏。此提示栏允许您在终端中描述所需的作，终端 Cmd K 将生成一个命令。您可以通过按 `esc` 接受命令，也可以立即使用 `Ctrl/⌘ + Enter` 运行命令。

![](/code/tool/cursor/028.png)
