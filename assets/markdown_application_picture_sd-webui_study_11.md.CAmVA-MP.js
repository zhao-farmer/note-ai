import{_ as a,c as l,o as e,a0 as t}from"./chunks/framework.DqNHTjo5.js";const o="/note-ai/application/picture/sd-webui/study/305.png",n="/note-ai/application/picture/sd-webui/study/304.png",r="/note-ai/application/picture/sd-webui/study/306.png",u="/note-ai/application/picture/sd-webui/study/307.png",s="/note-ai/application/picture/sd-webui/study/308.png",d="/note-ai/application/picture/sd-webui/study/309.png",p="/note-ai/application/picture/sd-webui/study/310.png",c="/note-ai/application/picture/sd-webui/study/311.png",f="/note-ai/application/picture/sd-webui/study/312.png",q=JSON.parse('{"title":"第十一章：超高清放大（显卡不够未验证）","description":"","frontmatter":{},"headers":[],"relativePath":"markdown/application/picture/sd-webui/study/11.md","filePath":"markdown/application/picture/sd-webui/study/11.md"}'),h={name:"markdown/application/picture/sd-webui/study/11.md"};function _(m,i,b,y,g,x){return e(),l("div",null,i[0]||(i[0]=[t('<h1 id="第十一章-超高清放大-显卡不够未验证" tabindex="-1">第十一章：超高清放大（显卡不够未验证） <a class="header-anchor" href="#第十一章-超高清放大-显卡不够未验证" aria-label="Permalink to &quot;第十一章：超高清放大（显卡不够未验证）&quot;">​</a></h1><h2 id="_11-1-为什么需要tiled-diffusion-vae" tabindex="-1">11.1 为什么需要Tiled Diffusion &amp; VAE？ <a class="header-anchor" href="#_11-1-为什么需要tiled-diffusion-vae" aria-label="Permalink to &quot;11.1 为什么需要Tiled Diffusion &amp; VAE？&quot;">​</a></h2><h3 id="_11-1-1-ai绘画的高分辨率挑战" tabindex="-1">11.1.1 AI绘画的高分辨率挑战 <a class="header-anchor" href="#_11-1-1-ai绘画的高分辨率挑战" aria-label="Permalink to &quot;11.1.1 AI绘画的高分辨率挑战&quot;">​</a></h3><p>从AI技术诞生的第一天起，人们对高分辨率的追求就没有停止过。然而，显卡性能尤其是显存的限制成为了这条道路上的最大阻碍。在原生的图像生成算法下，直接产出高分辨率的作品是非常困难的。本文介绍了一种高级分辨率放大技巧，可以实现从512像素到6K级别的跨越性飞升。最重要的是，它还能极大地降低显存负担，提高出图效率。优点：效果好、效率高、可控性强</p><p><img src="'+o+'" alt="" data-fancybox="gallery"></p><h3 id="_11-1-2-解决方案" tabindex="-1">11.1.2 解决方案 <a class="header-anchor" href="#_11-1-2-解决方案" aria-label="Permalink to &quot;11.1.2 解决方案&quot;">​</a></h3><p><code>Tiled Diffusion</code> + <code>Tiled VAE</code> + <code>ControlNet Tile</code>模型，这套组合是目前stablediffusion最好用的放大算法，通过使用Multi Diffusion和Tiled VAE等扩展，可以实现高分辨率放大。这些扩展可以将图像分块处理，提高分辨率并降低显存要求。同时，结合ControlNet Tile模型，还可以实现惊人的细节修饰效果。可以直接把图像生成壁纸级别的图像。下面我们看一下如何操作。</p><h2 id="_11-2-下载安装插件" tabindex="-1">11.2 下载安装插件 <a class="header-anchor" href="#_11-2-下载安装插件" aria-label="Permalink to &quot;11.2 下载安装插件&quot;">​</a></h2><p>新版本插件地址名称：multidiffusion-upscaler-for-automatic1111</p><p>插件地址：<a href="https://github.com/pkuliyi2015/multidiffusion-upscaler-for-automatic1111" target="_blank" rel="noreferrer">https://github.com/pkuliyi2015/multidiffusion-upscaler-for-automatic1111</a></p><p>安装成功后，在图生图界面下方会出现两个可折叠选单，分别是Tile VAE和Tile Diffusion。Tile VAE负责编码，Tile Diffusion负责生成。在操作时，需要同时启用这两个扩展，并与其他放大手法进行对比。</p><p><img src="'+n+'" alt="" data-fancybox="gallery"></p><h2 id="_11-3-tiled-diffusion-vae-插件介绍" tabindex="-1">11.3 <code>Tiled Diffusion &amp; VAE</code> 插件介绍 <a class="header-anchor" href="#_11-3-tiled-diffusion-vae-插件介绍" aria-label="Permalink to &quot;11.3 `Tiled Diffusion &amp; VAE` 插件介绍&quot;">​</a></h2><ul><li>Tiled这个词直译是”瓷砖、瓦片”等的意思，一般指对于图像、图案的平铺分块处理，而这个扩展的核心就是将图像”Tile”一 也就是区块化处理，</li><li>这样处理的核心作用不外乎两点，1、提高分辨率。2、降低绘制显存。直接画一张很大的图片，对你的显卡来说可能颇有压力，而这个扩展，就会按照一定的规则将它分割成一个个画起来更加轻松的小块，分别去绘制，再使用巧妙的方式“无缝拼接在一起，并借助亿点点算法来优化整体效果，这样就可以极大地降低A绘制过程中的负担</li><li>在这个扩展里，diffusion负责扩散，VAE负责编码，在AI生成图像的不同环节上各司其职,因此使用时两者都要启用。</li><li>和既往的文生图中的高分辨率修复对比，高分辨率修复无法突破显存的上限且绘制速度慢，而SD放大以及进阶的Ultimate Upscale有一些有分区块处理的雏形但可控性差，且绘制速度也偏慢，Tiled Diffusion直接表现出来的优势就是效果好、效率高、可控性强，并且以极其有效的方式优化了显存利用。</li></ul><h3 id="_11-2-1-区块化生成图" tabindex="-1">11.2.1 区块化生成图 <a class="header-anchor" href="#_11-2-1-区块化生成图" aria-label="Permalink to &quot;11.2.1 区块化生成图&quot;">​</a></h3><p><img src="'+r+'" alt="" data-fancybox="gallery"></p><h3 id="_11-2-2-插件介绍" tabindex="-1">11.2.2 插件介绍 <a class="header-anchor" href="#_11-2-2-插件介绍" aria-label="Permalink to &quot;11.2.2 插件介绍&quot;">​</a></h3><p><img src="'+u+'" alt="" data-fancybox="gallery"></p><h2 id="_11-3-基础使用方法" tabindex="-1">11.3 基础使用方法 <a class="header-anchor" href="#_11-3-基础使用方法" aria-label="Permalink to &quot;11.3 基础使用方法&quot;">​</a></h2><ol><li>在「文生图」或「图生图」启用「Tiled Diffusion」和「Tiled VAE」</li><li>对于「图生图」把重绘幅度调低到 0.3 左右</li><li>Tiled Diffusion 配置： <ul><li>Method： 选择 MultiDiffusion 可满足大部分情况</li><li>若搭配 ControlNet 一起使用时，可勾选 Move ControlNet tensor to CPU，可以有效降低显存</li><li>放大算法： 真人选 R-ESRGAN 4x+，二次元选 R-ESRGAN 4x+ Anime6B</li><li>勾选 Enable Noise Inversion： 可最大限度确保画面整体构图在放大后不会改变</li></ul></li><li>Tiled VAE 配置： <ul><li>编码器图块尺寸： 除非报错爆显存（CUDA Out of Memory）可以调低，否则不变</li><li>Fast Encoder Color Fix： 当图片放大后变得灰暗和不清晰时，才勾选</li></ul></li><li>放大倍率设置： <ul><li>方法一： 取消勾选「保持输入图像尺寸」，直接设置宽高为放大后期望的分辨率</li><li>方法二： 勾选「保持输入图像尺寸」，调整「缩放系数」</li></ul></li></ol><p><img src="'+s+'" alt="" data-fancybox="gallery"></p><h2 id="_11-4-进阶参数介绍" tabindex="-1">11.4 进阶参数介绍 <a class="header-anchor" href="#_11-4-进阶参数介绍" aria-label="Permalink to &quot;11.4 进阶参数介绍&quot;">​</a></h2><ol><li><p>潜空间</p><ul><li>潜空间(Latent Space)是一个扩散过程中的&quot;低维空间&quot;Stable Diffusion和之前的Diffusion扩散化模型相比，重点就在于将模型的计算空间，从像素空间经过数学变换，在尽可能保留细节信息的情况下降维到潜空间内进行压缩，然后再进行繁重的模型训练和图像生成计算。</li><li>基于潜空间的Diffusion模型与像素空间Diffusion模型相比，大大降低了内存和计算要求。通常Stable Diffusion所使用的潜空间编码缩减因子为8，那图像的长和宽都会被缩减8倍，一个512x512的图像在潜空间中直接变为64x64，节省了8x8=64倍的内存。因此，潜空间的大小与图像的真实尺寸之间，会存在一个“8倍”的换算比率。</li></ul></li><li><p>分块高度与分块宽度</p><ul><li>单次绘制区域大小或单次绘制内容多少</li><li>分块宽度和高度对应分辨率，是分辨率的1/8</li></ul></li><li><p>重叠大小</p><ul><li>需要重新绘制的区域大小</li><li>拼合是否融洽</li></ul></li><li><p>绘制次数</p><ul><li>类似于生成图中的“单批数量”参数，一次选择多少个块进行处理，显卡越小选择越低的值</li></ul></li><li><p>懒人方案</p><p><img src="'+d+'" alt="" data-fancybox="gallery"></p></li></ol><h2 id="_11-5-画一张4k的图" tabindex="-1">11.5 画一张4K的图 <a class="header-anchor" href="#_11-5-画一张4k的图" aria-label="Permalink to &quot;11.5 画一张4K的图&quot;">​</a></h2><p>在显卡性能充裕的情况下，可以使用Tiled Diffusion进一步突破分辨率极限，实现4K甚至6K级别的超高分辨率大图。</p><p>图像放大的挑战：传统的放大处理方法（如后期处理,即使用Tile diffusion也会生成多头多没用细节情况）无法保持细节水平，需要同时追求高分辨率和匹配的细节水平，把不足100像素的图像提升至4K甚至6K</p><ul><li>第一步：找一个能生成细节的模型，使用高清修复将图像提升到1080p级别，并建议使用latent系列（在丰富细节上提供更多帮助）放大算法和适当的重绘幅度（不能太低，0.5及以上）。会得到一个非常细节的图像。</li></ul><p><img src="'+p+'" alt="" data-fancybox="gallery"></p><ul><li>第二步：将图片发送至图生图，开启multi fusion和tile vae进行超级加倍，保持输入大小放大2倍，选择适合的放大算法和区块大小。 <ul><li>其他参数设置：放大算法选 Anime6B,建议降低重绘幅度（0.5）以避免噪声干预图像。潜空间分块宽度放大144.</li><li>噪声反转，不想改变画面结构和人脸，建议开启，但过高重绘幅度会干预图像，所以重绘降到了0.5.（也可以关闭试一下）</li></ul></li></ul><p><img src="'+c+'" alt="" data-fancybox="gallery"></p><h2 id="_11-6-配合controlnet生成更大的图片-6k" tabindex="-1">11.6 配合controlnet生成更大的图片 6K <a class="header-anchor" href="#_11-6-配合controlnet生成更大的图片-6k" aria-label="Permalink to &quot;11.6 配合controlnet生成更大的图片 6K&quot;">​</a></h2><p>将分辨率低的图像放入controlnet，然后选择启用，选择完美像素模式并勾选上tile，其它都保持默认，操作如下。（如果成图不太像，可增加下方控制权重数值）然后开启Tilde diffusion和Tiled VAE，分辨率升级3倍。开始跑图。</p><p><img src="'+f+'" alt="" data-fancybox="gallery"></p>',33)]))}const A=a(h,[["render",_]]);export{q as __pageData,A as default};
